#!/usr/bin/env ruby
# for Emacs, -*- mode: ruby -*- 

=begin

TODO 
-] manual page in HTML, for easy print 

DONE 
-] possibility of sorting results per log date [-s]
-] possibility of augmenting the search results [-l] 
-] possibility of restricting the date for the search [-d]


=end 





doc = <<HERED

<pre>
<b>NAME</b>

elastico -- Search log-lines stored in Elasticsearch.

<b>SYNOPSIS</b>

<b>$> elastico -h </b>                    # open the manual page with pager 'less'

<b>$> elastico -h html</b>                # write in STDOUT the manual as HTML page

<b>$> elastico [-d] [-l num] [-t TIMESTRING] [-s] [-h] QUERY </b>

<b>DESCRIPTION</b>

The fastest way to start to use this program is to read 
the examples section at the end of this document.

The syntax of the QUERY is the so called "Lucene Query Syntax".
It is almost indentical of the one accpeted by Kibana interface. 

By default the search is made into the <b>lclslogs</b> index, 
that is, we search into all log files lines stored in "psmetric01:/u2/logs"
and processed by Elasticsearch.

By default the search is made into the "src" field of each document.
The field contains the log line as red from 'psmetric01:/u2/logs/*/*' .

At the time of writing this text the "lclslogs" index contains
the following fields: 

<b>date</b>    : Date appearing in the logfile, extended to contain a guessed 
          value for the year.  

<b>machine</b> : Machine producing the message. 
          (eg. psmetric01, psana101 etc. )

<b>service</b> : Service producing the message. 
          (eg. cron, systemd, ... )

<b>message</b> : The message part of a log line. 
          (eg. "Cannot create socket to [psmonit]:8020 -- Connection refused")

<b>file</b>    : Logfile name where the message was found: 
          (eg. messages, cron, etc. )

<b>src</b>     : To simplify the search by shell this field was added in a second
          phase. It contains the log line as it is recorded in 'psmetric01:/u2/logs/*/*'.
          eg:
 "Dec  5 14:57:27 psana1507 monit[6494]: Cannot create socket to [psmonit]:8020 -- Connection refused"  

<b>PARAMETERS</b>

   <b>-d</b>  Shows <b>debug</b> informations. Intermediate values and global variables 
       that can simplify the understanding of the program in case something goes wrong.
       The debug information is printed at the end of the search results into STDERR.

   <b>-l</b>  Maximum number of <b>lines</b> to retrive from Elasticsearch. It must
       be a positive integer. Default to 20. The current maximum value is 10_000.
       This parameter is complementary to '-t'. When '-l' and '-t' are used together
       then '-l' prevails.

   <b>-h</b>  If given as the only parameter then the program will output 
       the documentation. If there are other parameters then the 
       matched words in output will be <b>highlighted</b>. Words 
       of specific fields as e.g. machine:foo will not be highlithed,
       it only applies to the default <b>src</b> field. Default to false.

   <b>-s</b> By default this program asks Elasticsearch to <b>sort</b> the results 
       by time. With this parameter Elasticsearch will be asked instead to 
       sort the results by <b>relevance</b>. 

   <b>-t</b> <b>Time window</b>. With this parameter we tell Elasticsearch we are 
       interested in filtering the search to to a specific time window.

       Sometimes the time limits will not be honoured and some of the older log will be 
       discarded. If '-t' parameter is called together with parameter '-l' then parameter 
       '-l' will prevail. If parameter '-t' is called without parameter '-l' and its 
       implied number of results would be larger than 10_000 then the default number of 
       lines will be printed, that is 20. When a cuts needs to be done on the loglines
       by default older logs are cut.       
  
       There are three accepted syntaxes to specifiy the time window:

         1] Delta backward in time from present time.
               -t ABS_DELTA
                  ABS_DELTA matches regexp /\\d+[dhm]/

               -t 10m             => filter results to the last 10 minutes 

         2] Delta backward/forward in time from a specified date-time instant.
               -t [YYYY]-[MMM]-[DD]-[HH:MM]__[+-]ABS_DELTA
               -t  2018-dec-10-10:30__-10m
               -t  dec-10__+3d 

         3] Explicit time window described by two date-time points. 
               -t [YYYY]-[MMM]-[DD]-[HH:MM]__[YYYY]-[MMM]-[DD]-[HH:MM]
               -t 2018-dec-10-15:50__2018-dec-15-16:30          
               -t dec-10__dec-15
               -t 14:30__15:15

       In general, when data is missing from a time point description values are 
       inferred from the current day. So dec-10 is auto completed to 2018-dec-10.       

       If the hour is missing then, on the left hand side of a '__' divider it is 
       auto-completed into the first second of the selected, on the right hand side of 
       a '__' divider it is autocompleted to the last second of the selected day. 
       
       Given the generality and flexibility of TIMESTRING it is better described
       by examples than by a formal grammar. See the Examples section.       


<b>REQUIREMENTS </b>

       -] <b>curl</b>. This software is not at all necessary and the dependency
          may be removed in future releases.   

       -] <b>less</b>. The "man" page visibile with 'elastico -h' goes to default to that pager. 
          There is not a separate man page to keep all the application in a single file,
          code and documentation.

       -] <b>ruby</b>. This software is written in Ruby. Rationale; Ruby is some kind
          of a OO version of Perl. Ideal for intense regexp work. 
    
<b>REFERENCES </b> 

       -] "Lucene Query Syntax", see https://goo.gl/GPPSdJ

       -] "Elasticsearch the definitive guide" by Gromley, Tong -- O'Reilly 2015.

<b>AUTHOR</b>

Dr. Nicola Mingotti, nicola.mingott@slac.stanford.edu. 

The application has been last modified on date 21 Dec 2018.
  
<b>EXAMPLES </b>

# Generic search over a word ... here a machine name 
.b $> elastico psana101        

# Generic search over a word ... here a service name 
.b $> elastico monit           

# Generic search over a word ... here a user name    
.b $> elastico nmingott        

# Generic search over an approximate username 
# Quote is necessary because "~" is special character in Bash.
.b $> elastic 'omar~'

# Generic search over everything that can be: psana101, psana103 etc.
# Observe that the quotes are fundamental to stop Bash from interpreting
# "*". 
.b $> elastico 'psana*'        

# Search all log lines where there appear the work "nmingott" somwhere
# AND the machine is a string which contains "metric".
# Booleans MUST BE upcase words.
.b $> elastico 'nmingott AND machine:*metric*'

# Elaboration respect to the previous example, matching all lines where "nmingott"
# appers and the machine is a string containing *ana* or *metric*.
# This examples shows that (...) is the syntax for  
# grouping of booleans and that it is not necessary to write
# (machine:*metric* OR machine:*ana*) in full.
.b $> elastico 'nmingott AND machine:(*metric* OR *ana*)'

# See last logs in psmetrico01
.b $> elastico 'machine:psmetric01'

# See the last 200 log lines in psmetric01
.b $> elastico -l 200 'machine:psmetric01'

# See the log lines that best metch a string,
# return results according to Elasticsearch 'relevance' 
# algorithm, not by date. In general, more time the string
# is matched in the log line the more a line is 'relevant'.
.b $> elastico -S 'ana*' 

# Hilight the search results 
.b $> elastico -l 20 -h 'wilko'

# Autocomplete only for a specific number of characters
# In this case all 'psana' followed by 3 characters.
.b $> psana -h 'psana???'

# === <b>Time Window Selections</b> ===========

# Show all logs related to 'psana???' in the last
# 5 minutes. With the same syntax we can use the specifiers
# <b>m</b> minutes, <b>h</b> hours, <b>d</b> days.
.b $> elastico -t 5m 'psana???'

# If we are unhappy about the result and suspect something
# is wrong the first thing to do is to check how 'elastico' interpreted
# the time window. The information is written after the search results, on STDERR.
.b $> elastico -d -t 5m 'psana???'

# We want to see the results moving around a specific
# point in time. Suppose 5 minutes after 
# the date 15 dic 2018 at 13:00
.b $> elastico -t 2018-dec-15-13:00__+5m 'psana???'
or, if we are still in 2018: 
.b $> elastico -t dec-15-13:00__+5m 'psana???'

# We want to see the results moving around a specific
# point in time. Suppose 10 minutes before
# the date 15 dic 2018 at 13:00
.b $> elastico -t 2018-dec-15-13:00__-10m 'psana???'
or, if we are still in 2018: 
.b $> elastico -t dec-15-13:00__-10m 'psana???'

# We want to see the results between two specific points in time 
.b $> elastico  -t 2018-dec-15-13:00__2018-dec-16-14:25 'psana101'
or, if we are still in 2018 
.b $> elastico  -t dec-15-13:00__dec-16-14:25 'psana101'

# We want to see the data in two specific date, all day hours.
# If the hour is not specified and there are two specific date-time
# points then the hour of the date on the left hand side is 00:00,
# the hour for the right hand side is 23:59.
.b $> elastico  -t dec-15__dec-16 'psana103'

# Filter all today logs generated beween 10:30 and 11:00.
.b $> elastico  -t 10:30__11:00 'psana103'


</pre>

HERED



require 'json'
require 'date'
require 'tempfile'

# require 'pry'


# Example of Lucene Query sintax to Elasticsearch CURL 
# curl -XGET 'http://psmetric04:9200/lclslogs/_search?pretty=true' -H 'Content-Type: application/json' -d '{"query": { "query_string": { "default_field":"src", "query":"psmetric01"     }      }     }'

# ==========================================================
# Global variables determined with defaul values 
# that can be modified by command line parameters.
# =========================================================
#
# -] Upper limit to the number of output lines required. 
#    This value is overriddend if the parameter "-t" is set.
# -] DEFAULT_LIMIT is useful because it is a way to discover if the user
#    changed $LIMIT from a command line parameter. 
# -] Limit by time is the number of lines to 
# 
$LIMIT = 20 
$LIMIT_DEFAULT = 20
$LIMIT_BY_TIME = nil
$LIMIT_IN_TIME_AND_SIZE = nil 
#
# If true values are returned sorted by date, if false
# the lines are returned by Elasticsearch 'relevance' sort.
#
$SORTED = true
# 
# 
$HIGHLIGHT = false
# 
# If this variable is set to 'true' then the variable $MYDEBUG_VALS 
# is printed in output. MYDEBUG_VALS contains various intermediate 
# results of interest.
#  
$MYDEBUG = false 
$MYDEBUG_VALS = {}
#
# For filtering according to date 
# Selecte all values in interval [$DATE0, $DATE1]
# The two values are in milliseconds. "$TIME_FILTER" 
# is true iff the time window has been specified on the command line.
$TIME_FILTER = false;
$DATE0 = 0
# checked considtente with "date" :
# $> ruby -e 'puts "unix: #{`date "+%s"`}"; puts "ruby: #{Time.now.to_i} " '
$DATE1 = ((Time.now.to_i)*1000)

# =========================================================


# -] Make a string bold for the terminal 
def bolden(str)
  out = "\033[1m" + str + "\033[0m"
end

# -] replace blocks <em> ... </em> with Bash escape code
#    for bold.
def emphasis(str)
  out = str.gsub /<em>(.*?)<\/em>/, "\033\[1m\\1\033\[0m"
end

# TODO 
# modify 
# The sistem know the correct timezone, if PDF or PST 
# $> date '+%Z' => PST  o PDT 
# $> date '+%:z' => -08:00 o -07:00
def dateTimeToPST(dateTime)
  d = dateTime
  # this can contain "-08:00" or "-07:00" if we are in San Francisco ! 
  timeZoneDelta = `date '+%:z'`
  # if the timezone is already "-08:00" do nothing
  # return d if d.zone == "-08:00" 
  out = DateTime.new(d.year, d.month, d.day, d.hour, d.minute, d.second, timeZoneDelta )
end 


# -] function that analyzes the time string and return 
#    two DateTime objects representing the time window of interest.
# 
# IN: 'timeStr' : can be something like:
#      "2d"
#      "5h" 
#      "10m"    
#      "2018-dec-06-10:30__+2d"
#      "2018-dec-06-10:30__2018-dec-08"
#      "06-dec__15-dec"
#      .... 
# OUT: [dateA, dateB] 
#      date[A|B] are DateTime objects, they are not ordered, dateA can be larger than dateB
# 
def workOnTimeString(timeStr) 
  str = timeStr.dup 
  # timeStr e' del tipo: 1h, 5d, etc. 
  if  (m = str.match /^(?<val>\d+)(?<unit>[mhd])$/) then 
    val = m['val'].to_i
    seconds = {'m' => 60, 'h' => 60*60, 'd' => 60*60*24}
    # tempo corrente come epoch in secondi 
    # 
    rhsTime = DateTime.now
    lhsTime = rhsTime.to_time.to_i - (m['val'].to_i * seconds[m['unit']])
    lhsTime = lhsTime + DateTime.now.to_time.utc_offset
    lhsTime = DateTime.strptime(lhsTime.to_s, "%s")
    # 
  elsif (m = str.match /^(?<lhs>.*)__(?<rhs>.*)$/) then
    lhs = m['lhs'].dup.strip
    rhs = m['rhs'].dup.strip
    # puts "lhs: #{lhs}"
    # puts "rhs: #{rhs}"
    # 
    # lhs is always a point in time, that can be expressed as 
    # 2018-dec-06, dec-06, 06-10:30:31, 05-10:30
    # if YYY is not set is the current year 
    # if MM is not set is the current month
    # if SS is not set is zero 
    # if HH:MM is not set it is 00:00 (the first minute of the day)
    begin 
    lhsTime = nil
    # full date : 2018-dec-06-10:30
    if lhs.match /^\d{4}-\w{3}-\d{1,2}-\d{1,2}:\d{1,2}$/ then 
      lhsTime = DateTime.strptime(lhs, '%Y-%b-%d-%H:%M')
    # no year : dec-06-10:30 
    elsif lhs.match /^\w{3}-\d{1,2}-\d{1,2}:\d{1,2}$/ then 
      lhsTime = DateTime.strptime(lhs, '%b-%d-%H:%M')
    # no time : 2018-dec-06 
    elsif lhs.match /^\d{4}-\w{3}-\d{1,2}$/ then 
      lhsTime = DateTime.strptime(lhs, '%Y-%b-%d')
    # no year, no time : dec-06
    elsif lhs.match /^\w{3}-\d{1,2}$/ then 
      lhsTime = DateTime.strptime(lhs, '%b-%d')
    # only time : 15:30
    elsif lhs.match /^\d{1,2}:\d{1,2}$/ then 
      lhsTime = DateTime.strptime(lhs, '%H:%M')
    else
      STDERR.puts "Error, time format not recognized."
      exit(1)
    end
    # puts "lhsTime: #{lhsTime}"
    rescue => ex 
      STDERR.puts "Exception in parsing dates, check e.g. month names."
      exit(3)
    end

    # 
    # rhs can be a point in time, or a delta respect to lhs time.
    # 
    # if rhs is a delta it a can be: e.g. +1d, 5h, 20h, -12d ... 
    # 
    begin 
    rhsTime = nil 
    if (m = rhs.match(/^(?<sign>[+-])(?<val>\d+)(?<unit>[mhd])$/)) then
      seconds = {'m' => 60, 'h' => 60*60, 'd' => 60*60*24}
      if m['sign'] == '+' then 
        # binding.pry
        rhsTime = lhsTime.to_time.to_i + (m['val'].to_i * seconds[m['unit']])
        rhsTime = DateTime.strptime(rhsTime.to_s, "%s")
      else
        rhsTime = lhsTime.to_time.to_i - (m['val'].to_i * seconds[m['unit']])        
        rhsTime = DateTime.strptime(rhsTime.to_s, "%s")
      end
    # 
    # Now we see the case in which rhs if fully described 
    # complete: 2018-dec-06-10:31
    elsif rhs.match /^\d{4}-\w{3}-\d{1,2}-\d{1,2}:\d{1,2}$/ then 
      rhsTime = DateTime.strptime(rhs, '%Y-%b-%d-%H:%M')
    # no year : dec-06-10:30 
    elsif rhs.match /^\w{3}-\d{1,2}-\d{1,2}:\d{1,2}$/ then 
      rhsTime = DateTime.strptime(rhs, '%b-%d-%H:%M')
    # no time : 2018-dec-06 
    # in this case the time is the last minute of the day.
    elsif rhs.match /^\d{4}-\w{3}-\d{1,2}$/ then 
      tmp = DateTime.strptime(rhs, '%Y-%b-%d')
      rhsTime = DateTime.new(tmp.year, tmp.month, tmp.day, 23, 59, 59)
    # no year, no time : dec-06
    elsif rhs.match /^\w{3}-\d{1,2}$/ then 
      tmp = DateTime.strptime(rhs, '%b-%d')
      rhsTime = DateTime.new(tmp.year, tmp.month, tmp.day, 23, 59, 59)
    # only time : 15:30
    elsif rhs.match /^\d{1,2}:\d{1,2}$/ then 
      rhsTime = DateTime.strptime(rhs, '%H:%M')
    # 
    # Finally the case in which 'rhs' has not a recognizable format 
    else 
      STDERR.puts "Error, time format not recognized."
      exit(1) 
    end
    rescue => ex 
      STDERR.puts "Exception in parsing dates, check e.g. month names."
      exit(3)
    end
    # puts "rhsTime: #{rhsTime}"
    # exit (2)
  else
    STDERR.puts "Error, the time string '#{timeStr}' for parameter '-t' has an unknown format."
    exit(1);
  end
  # 
  # Return the two time limits. The first time is always before (in time) respect to the second one.
  # 
  lhsTime = dateTimeToPST(lhsTime)
  rhsTime = dateTimeToPST(rhsTime)
  if lhsTime == rhsTime then 
    STDERR.puts "Error. The time interval is empty, the search will be empty."
    exit(1)
  elsif lhsTime < rhsTime then
    out = [lhsTime, rhsTime]
    $MYDEBUG_VALS['lhsTime'] = lhsTime;
    $MYDEBUG_VALS['rhsTime'] = rhsTime;
  else
    out = [rhsTime, lhsTime]
    $MYDEBUG_VALS['lhsTime'] = rhsTime;
    $MYDEBUG_VALS['rhsTime'] = lhsTime;
  end
  out
end


# -] If there are not arguments print error message and quit
#
if ARGV.length == 0 then
  STDERR.puts "Error, this program requires at least one argument. "
  STDERR.puts "Use arg '-h' to see the documentation. "
  exit(1)
end 

# -] If "-h" is first argument show the documentation
#
if (ARGV.length <= 2) and (ARGV[0] == "-h") then 

  if ARGV.length == 1 then 
    Tempfile.open('elasticoManual', '/tmp') { |f|  
      doc2 = doc.dup
      # get rid of HTML formatting 
      doc2.gsub! /<pre>/, ""
      doc2.gsub! /<\/pre>/, ""    
      # substitute "<b>" with terminal "bold"
      doc2.gsub! /<b>(.*?)<\/b>/, bolden('\1')
      doc2.split(/\n/).each do |l|
        if l.match(/^\.b/) then 
          tmp = l.sub(/^\.b /, "")
          f.puts " " + bolden(tmp)
        else
          f.puts " " + l
        end
      end
      system("less -R #{f.path}")
    }
    exit(0); 

  # 
  # if we want the HTML page the we need some modifications 
  # 
  elsif (ARGV.length == 2) and (ARGV[0] == "-h") and (ARGV[1] == "html")
    doc2 = doc.dup
    puts "<html>"
    puts "<body>"
    doc2.split(/\n/).each do |l|
      if l.match(/^\.b/) then 
        tmp = l.sub(/^\.b\ *(.*)$/, '<b>\1</b>')
        puts " " + tmp
      else
        puts " " + l
      end
    end
    puts "</body>"
    puts "</html>"
    exit(0);     
  end
end 

# -] Parameters consistency check.
#    parameters "-t" and "-l" can not be set on the same query, they
#    give inconsistent directions because "-t" defines implicitely the number of lines
#    it needs to get, "-l" does it explicitely.
# 
if ( ARGV.include?("-t") and 
     ARGV.include?("-l") ) then 
  # STDERR.puts "Error, parameters '-l' and '-t' are conflicting and can't be put on the same query."
  # exit(1)
  $LIMIT_IN_TIME_AND_SIZE = true 
end 

# -] Parametro "-d" 
#    per l'attivazione dei messaggi di debug
if ARGV.include?("-d") then 
  $MYDEBUG = true;
end 



# -] get parameters values and set constants 
# 
(0..(ARGV.length-2)).each do |idx|
  par = ARGV[idx]
  if par == "-S" then 
    $SORTED = false;
  elsif par == "-h" then 
    $HIGHLIGHT = true
  elsif par == "-H" then 
    $HIGHLIGHT = false
  #
  # "-l" : limit number of results 
  elsif par == "-l" then
    if ARGV[idx+1] == nil then 
      STDERR.puts "Error, an argument is needed after parameter '-l'."
      exit(1)
    end
    val = ARGV[idx+1]
    if (not val.match /\d+/) then 
      STDERR.puts "Error, argument of '-l' is required to be a positive integer."
      exit(1)
    end
    if (val.to_i > 10_000) then 
      STDERR.puts "Error, at the moment the maxium number of lines retrivable is 10_000."
      exit(1)
    end
    $LIMIT = ARGV[idx+1].to_i
  # 
  # "-t" : time window for selected results 
  elsif par == "-t" then 
    if ARGV[idx+1] == nil then 
      STDERR.puts "Error, an argument is needed after parameter '-t'."
      exit(1)      
    end
    # get the DateTime objects representing the time interval of interest
    dt0, dt1 = workOnTimeString(ARGV[idx+1])
    # convert the tims in milisseconds Epochs and set the globa variables 
    $TIME_FILTER = true;
    $DATE0 = (dt0.to_time.to_i * 1_000)
    $DATE1 = (dt1.to_time.to_i * 1_000)    
    # exit(1);
  end  
end 


# -] Lucene Query String is always the last argument in the shell command line 
# 
LQSTR = ARGV[-1].dup


# Accepts a Lucene query string "lucQstr", calls Elasticsearch via "curl" 
# and return the response as a string.
# We use "curl" to avoid the load of extra libraries, this may be changed.
def curlQuery(lucQstr="*", sorted: true, size: 20, highlight: false, count: false )

  if sorted then 
    sortedStr = ',"sort": {"date": {"order": "desc"}}  '
  else
    sortedStr = ""
  end

  if highlight then 
    highlightStr = ',"highlight": { "fields": { "src": {} } }'
  else
    highlightStr = ""
  end

  # The operation type can be "_search", the get the results 
  # of "_count" to count the possible results 
  opType = "_search"
  if count then 
    opType = "_count"
    sortedStr = ""
    highlightStr = ""
  else
    opType = "_search?size=#{size}"
  end

  # The command include newlines and extra-spaces which are extremely useful
  # for readability, but then they must be removed.
  # -s : silent mode, does not show the progress bar 
  cmd = %Q[ curl -s -XGET 'http://psmetric04:9200/lclslogs/#{opType}' 
                 -H 'Content-Type: application/json' 
                 -d '{ "query": { 
                        "bool": { 
                          "must": { 
                            "query_string": { 
                                      "default_field" : "src", 
                                      "query"         : "#{lucQstr}" 
                             }
                           }, 
                           "filter": { 
                              "range": { 
                                 "date": { 
                                     "gt" : "#{$DATE0}", 
                                     "lt" : "#{$DATE1}" 
                                 } 
                              }
                           }
                         } 
                        }
                       #{sortedStr}
                       #{highlightStr}
                     } ' ]


  # Store the query for debug purposes 
  if count == true then 
    $MYDEBUG_VALS['counterQuery'] = cmd.dup;
  else 
    $MYDEBUG_VALS['query'] = cmd.dup;
  end

  # Remove newlines 
  cmd.gsub! /\n/, " ";
  # Remove extra spaces 
  cmd.gsub! /\s+/, " ";

  # puts "DBG> #{cmd}" 
  out = `#{cmd}`
  # puts "DBG> #{out}" 
  out 
end


# -] Buffer containing all lines that will be printed 
lineBuffer = []

# -] If the search is by date get the number of results before
#    actually get them.     
#    The result is something similar to this:
#    {"count":19,"_shards":{"total":5,"successful":5,"skipped":0,"failed":0}}
# 
# -] "-l" will override "-t", always. 
#    Remember that "-l" control $LIMITS, but $LIMITS is defined by default as 20.
#    topmost region of the code. 
# 
# -] If "totalResultsByTime" is greater than $LIMITS (-l) then 
#    $LIMITS will not be changed, and $LIMITS was set to a value different from
#    the default, that is 20 than $LIMITS will prevail. 
# 
# -] If "totalResultsByTime" is greater than 10_000 then 
#    
# 
if $TIME_FILTER == true then 
  tmp = curlQuery( "* AND ( #{LQSTR} )", count: true)
  totalResultsByTime = JSON.parse(tmp)["count"].to_i
  # to transporta this value at the end of the script and take decisions 
  # on the messages to show.
  $LIMIT_BY_TIME = totalResultsByTime
  # puts "Total documents to retrive: #{totalResultsByTime}."
  $MYDEBUG_VALS['counterQueryResult'] = tmp
  $MYDEBUG_VALS['numDocPerTimeWin'] = totalResultsByTime
  if ($LIMIT_BY_TIME >= 10_000) then 
    # -] since $LIMIT_BY_TIME is not a good value then $LIMIT is USED 
    #    so $LIMIT is not modified.
    nil
    # STDERR.puts "Error, the number of loglines to get would be #{totalResultsByTime}."
    # STDERR.puts "Please refine your search criteria, the maximum number of lines allowed in output is 10_000."
    # exit(1)
  else 
    # if $LIMIT_BY_TIME is a good value than it prevails over $LIMIT, 
    # but if $LIMIT has been given by the user then $LIMIT will prevail.
    if ($LIMIT == $LIMIT_DEFAULT) then 
      $LIMIT = $LIMIT_BY_TIME
    else
      # if $LIMIT != $LIMIT_DEFAULT it means that the user has specified its value
      # on the command line. In this case $LIMIT will prevail over the time.
      nil 
    end
  end 
end

# -] Make the query to Elasticsearch and store all results 
#    in the buffer "lineBuffer".
# 
tmp = curlQuery( "* AND ( #{LQSTR} )", size: $LIMIT, 
                 sorted: $SORTED, highlight: $HIGHLIGHT, count: false)
JSON.parse(tmp)['hits']['hits'].each do |el|
  if $HIGHLIGHT then
    lineBuffer.push( el['highlight']['src']  )
  else
    lineBuffer.push( el['_source']['src'] )
  end
end; nil 


# -] Printer all lines in "lineBuffer".
lineBuffer.reverse.each do |l|
  next if l.nil?
  if $HIGHLIGHT then 
    puts emphasis(l[0])
  else
    puts l
  end
end 

# =====================================================================================

# -] Print informative message if some automatic selections were made on the 
#    data to display.

if ($LIMIT_IN_TIME_AND_SIZE == true) then 
  STDERR.puts "=== WARNING === Parameters '-t' and '-l' are not independent, one will prevail. "
end 

if (($LIMIT_BY_TIME != nil) and 
    ($LIMIT_BY_TIME > 10_000) and 
    ($LIMIT == $LIMIT_DEFAULT)) then  
     STDERR.puts "=== WARNING === Matching log-lines: #{$LIMIT_BY_TIME}, exceeding 10_000, cut to default: #{$LIMIT_DEFAULT}. " 
end 

if (($LIMIT_IN_TIME_AND_SIZE != nil) and 
    ($LIMIT_BY_TIME >= $LIMIT)) then  
     STDERR.puts "=== WARNING === logline limit implied by '-t': #{$LIMIT_BY_TIME} exceeds limit imposed by '-l': #{$LIMIT}. => '-l' prevails. " 
end 

if (($LIMIT_IN_TIME_AND_SIZE != nil) and 
    ($LIMIT_BY_TIME < $LIMIT)) then  
     STDERR.puts "=== WARNING === logline limit implied by '-t': #{$LIMIT_BY_TIME} does not exceed limit imposed by '-l': #{$LIMIT}. => '-t' is honoured. " 
end 



# =====================================================================================


# -] Print to STDERR debug informations if parameter "-d" is in ARGV.
#
if ($MYDEBUG == true) then 

  STDERR.puts <<EOD

  ========= Debug Informations ========================================================
  -] Limit the number of docuements to: $LIMIT 
     => #{$LIMIT}

  -] Command line arguments ARGV
     => #{ARGV}

  -] left side of the time window selected (lhs)
     => #{$MYDEBUG_VALS['lhsTime']}

  -] right side of the time window selected (rhs)
     => #{$MYDEBUG_VALS['rhsTime']}

  -] Epoch values in millisec sent to Elasticsearch time range filter window [$DATE0, $DATE1]
     => [ #{$DATE0}, #{$DATE1} ]

  -] Expolorative query for Elastic to count results per time window (if specified parameter '-t')
     => #{$MYDEBUG_VALS['counterQuery']}

  -] Explorative query result
     => #{$MYDEBUG_VALS['counterQueryResult']}

  -] Curl query for Elastic, to get results
     => #{$MYDEBUG_VALS['query']}

  ====================================================================================

EOD
end 






